using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

using Tmds.DBus.Protocol;


namespace Tmds.DBus.SourceGenerator
{
    [Generator]
    public partial class DBusSourceGenerator : ISourceGenerator
    {
        /*public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Test.g.cs", "tetswsfsdf"));
            
            IncrementalValuesProvider<GeneratorAttributeSyntaxContext> classProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
                "Tmds.DBus.SourceGenerator.DBusInterfaceAttribute",
                static (node, _) => node is ClassDeclarationSyntax,
                static (context, _) => context
            );
            
            

            context.RegisterSourceOutput(classProvider, static (productionContext, syntax) =>
            {
                productionContext.AddSource("Test.g.cs", "Test");
                ClassDeclarationSyntax declaration = (syntax.TargetNode as ClassDeclarationSyntax)!;
                INamedTypeSymbol? declaredClass = syntax.SemanticModel.GetDeclaredSymbol(declaration);
                if (declaredClass is null) return;
                string @namespace = string.Join(".", declaredClass.ContainingNamespace.ConstituentNamespaces.Select(static x => x.Name));
                TypeDeclarationSyntax? typeDeclarationSyntax = GenerateProxy(syntax.SemanticModel, declaration, syntax.Attributes[0]);
                if (typeDeclarationSyntax is null) return;
                CompilationUnitSyntax compilationUnitSyntax = MakeCompilationUnit(typeDeclarationSyntax);
                productionContext.AddSource($"{@namespace}.{declaredClass.Name}.g.cs", compilationUnitSyntax.GetText(Encoding.UTF8));
            });
        }*/

        private static CompilationUnitSyntax MakeCompilationUnit(NamespaceDeclarationSyntax namespaceDeclaration) =>
            CompilationUnit().AddMembers(namespaceDeclaration
                .WithLeadingTrivia(
                    TriviaList(
                        Comment("// <auto-generated/>"),
                        Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
                        Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                    )
            ).NormalizeWhitespace();

        private static TypeDeclarationSyntax? GenerateProxy(SemanticModel semanticModel, TypeDeclarationSyntax declaration, AttributeData attributeData)
        {
            if (attributeData.ConstructorArguments[0].Value is not string path || attributeData.ConstructorArguments[1].Value is not string @interface)
                return null;
            ClassDeclarationSyntax cl = ClassDeclaration(declaration.Identifier)
                .WithModifiers(declaration.Modifiers);

            FieldDeclarationSyntax connectionField = FieldDeclaration(VariableDeclaration(ParseTypeName(nameof(Connection)))
                    .AddVariables(VariableDeclarator("_connection")))
                .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword));

            ConstructorDeclarationSyntax ctor = ConstructorDeclaration(declaration.Identifier)
                .AddModifiers(Token(SyntaxKind.PublicKeyword))
                .AddParameterListParameters(
                    Parameter(Identifier("connection")).WithType(ParseTypeName(nameof(Connection))))
                .WithBody(Block(
                    ExpressionStatement(
                        AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression,
                            IdentifierName("_connection"),
                            IdentifierName("connection")))));

            cl = cl.AddMembers(connectionField, ctor);
            return AddMethods(cl, semanticModel, declaration, path, @interface);
        }

        private static ClassDeclarationSyntax AddMethods(ClassDeclarationSyntax cl, SemanticModel semanticModel, TypeDeclarationSyntax declaration, string path, string @interface)
        {
            foreach (MethodDeclarationSyntax methodDeclaration in declaration.Members.OfType<MethodDeclarationSyntax>())
            {
                string methodName = methodDeclaration.Identifier.Text.Substring(0, methodDeclaration.Identifier.Text.Length - 5);
                string createMethodIdentifier = $"Create{methodName}Message";

                BlockSyntax createMessageBody = Block().AddStatements(
                    LocalDeclarationStatement(VariableDeclaration(ParseTypeName(nameof(MessageWriter)),
                        SingletonSeparatedList(
                            VariableDeclarator("writer")
                                .WithInitializer(EqualsValueClause(
                                    InvocationExpression(
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("_connection"), IdentifierName(nameof(Connection.GetMessageWriter)))))))))
                    .WithUsingKeyword(Token(SyntaxKind.UsingKeyword)),
                    ExpressionStatement(
                        InvocationExpression(
                                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("writer"), IdentifierName(nameof(MessageWriter.WriteMethodCallHeader))))
                            .AddArgumentListArguments(
                                Argument(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("_connection"), IdentifierName(nameof(Connection.UniqueName)))),
                                Argument(MakeLiteralExpression(path)),
                                Argument(MakeLiteralExpression(@interface)),
                                Argument(MakeLiteralExpression(ParseSignature(semanticModel, methodDeclaration))),
                                Argument(MakeLiteralExpression(methodName)))));

                foreach (ParameterSyntax parameter in methodDeclaration.ParameterList.Parameters)
                {
                    if (parameter.Type is null)
                        throw new ArgumentException("Cannot parse parameter.");
                    createMessageBody = createMessageBody.AddStatements(
                        ExpressionStatement(
                            InvocationExpression(
                                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("writer"), IdentifierName(ParseWriteMethod(semanticModel, parameter))))));
                }

                createMessageBody = createMessageBody.AddStatements(
                    ReturnStatement(
                        InvocationExpression(
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("writer"),
                                IdentifierName(nameof(MessageWriter.CreateMessage))))));

                ParenthesizedLambdaExpressionSyntax messageValueReaderLambda = ParenthesizedLambdaExpression()
                    .AddParameterListParameters(
                        Parameter(Identifier("message")).WithType(ParseTypeName(nameof(Message))),
                        Parameter(Identifier("state")).WithType(NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))))
                    .WithExpressionBody(
                        InvocationExpression(
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, InvocationExpression(
                                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("message"), IdentifierName(nameof(Message.GetBodyReader)))),
                                IdentifierName($"{nameof(Reader)}.{ParseReadMethod(semanticModel, methodDeclaration.ReturnType)}"))));

                MethodDeclarationSyntax proxyMethod = MethodDeclaration(methodDeclaration.ReturnType, methodDeclaration.Identifier)
                    .WithModifiers(methodDeclaration.Modifiers)
                    .WithBody(Block(
                    ReturnStatement(
                        InvocationExpression(
                                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("_connection"),
                                    IdentifierName(nameof(Connection.CallMethodAsync))))
                            .AddArgumentListArguments(
                                Argument(
                                    InvocationExpression(
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName(createMethodIdentifier)))),
                                Argument(messageValueReaderLambda))),
                    LocalFunctionStatement(ParseTypeName(nameof(MessageBuffer)), createMethodIdentifier)
                        .WithBody(Block(createMessageBody))));

                cl = cl.AddMembers(proxyMethod);
            }

            return cl;
        }

        public void Initialize(GeneratorInitializationContext context) { }

        public void Execute(GeneratorExecutionContext context)
        {
            IEnumerable<ClassDeclarationSyntax> classNodes = context.Compilation.SyntaxTrees.SelectMany(static tree => tree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>());
            INamedTypeSymbol? attributeType = context.Compilation.GetTypeByMetadataName("Tmds.DBus.SourceGenerator.DBusInterfaceAttribute");
            foreach (ClassDeclarationSyntax classNode in classNodes)
            {
                SemanticModel semanticModel = context.Compilation.GetSemanticModel(classNode.SyntaxTree);
                INamedTypeSymbol? declaredClass = semanticModel.GetDeclaredSymbol(classNode);
                if (declaredClass is null) return;
                AttributeData? attribute = declaredClass.GetAttributes().FirstOrDefault(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, attributeType));
                if (attribute is null) continue;
                string @namespace = declaredClass.ContainingNamespace.ToDisplayString();
                TypeDeclarationSyntax? typeDeclarationSyntax = GenerateProxy(semanticModel, classNode, attribute);
                if (typeDeclarationSyntax is null) return;
                NamespaceDeclarationSyntax namespaceDeclaration = NamespaceDeclaration(IdentifierName(@namespace))
                    .AddUsings(
                        UsingDirective(IdentifierName("Tmds.DBus.Protocol")))
                    .AddMembers(typeDeclarationSyntax);
                CompilationUnitSyntax compilationUnitSyntax = MakeCompilationUnit(namespaceDeclaration);
                context.AddSource($"{@namespace}.{declaredClass.Name}.g.cs", compilationUnitSyntax.GetText(Encoding.UTF8));
            }
        }
    }
}
